# Snapshot report for `test/cli.test.js`

The actual snapshot is saved in `cli.test.js.snap`.

Generated by [AVA](https://ava.li).

## cjs file not generated when --no-cjs passed

> Snapshot 1

    'ğŸ“¦ Writing ES Module dist file: tmp/one.js'

> Snapshot 2

    `function greeting () {âŠ
      return 'Hello World'âŠ
    }âŠ
    âŠ
    export default greeting;âŠ
    `

## dist file generated using custom plugins

> Snapshot 1

    'ğŸ’¿ Writing CommonJS dist file: tmp/three.js'

> Snapshot 2

    `'use strict';âŠ
    âŠ
    Object.defineProperty(exports, '__esModule', { value: true });âŠ
    âŠ
    //âŠ
    //âŠ
    //âŠ
    //âŠ
    //âŠ
    //âŠ
    //âŠ
    âŠ
    var script = {âŠ
      data: () => ({ name: 'World' })âŠ
    };âŠ
    âŠ
    function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifierâŠ
    /* server only */âŠ
    , shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {âŠ
      if (typeof shadowMode !== 'boolean') {âŠ
        createInjectorSSR = createInjector;âŠ
        createInjector = shadowMode;âŠ
        shadowMode = false;âŠ
      } // Vue.extend constructor export interop.âŠ
    âŠ
    âŠ
      var options = typeof script === 'function' ? script.options : script; // render functionsâŠ
    âŠ
      if (template && template.render) {âŠ
        options.render = template.render;âŠ
        options.staticRenderFns = template.staticRenderFns;âŠ
        options._compiled = true; // functional templateâŠ
    âŠ
        if (isFunctionalTemplate) {âŠ
          options.functional = true;âŠ
        }âŠ
      } // scopedIdâŠ
    âŠ
    âŠ
      if (scopeId) {âŠ
        options._scopeId = scopeId;âŠ
      }âŠ
    âŠ
      var hook;âŠ
    âŠ
      if (moduleIdentifier) {âŠ
        // server buildâŠ
        hook = function hook(context) {âŠ
          // 2.3 injectionâŠ
          context = context || // cached callâŠ
          this.$vnode && this.$vnode.ssrContext || // statefulâŠ
          this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext; // functionalâŠ
          // 2.2 with runInNewContext: trueâŠ
    âŠ
          if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {âŠ
            context = __VUE_SSR_CONTEXT__;âŠ
          } // inject component stylesâŠ
    âŠ
    âŠ
          if (style) {âŠ
            style.call(this, createInjectorSSR(context));âŠ
          } // register component module identifier for async chunk inferenceâŠ
    âŠ
    âŠ
          if (context && context._registeredComponents) {âŠ
            context._registeredComponents.add(moduleIdentifier);âŠ
          }âŠ
        }; // used by ssr in case component is cached and beforeCreateâŠ
        // never gets calledâŠ
    âŠ
    âŠ
        options._ssrRegister = hook;âŠ
      } else if (style) {âŠ
        hook = shadowMode ? function () {âŠ
          style.call(this, createInjectorShadow(this.$root.$options.shadowRoot));âŠ
        } : function (context) {âŠ
          style.call(this, createInjector(context));âŠ
        };âŠ
      }âŠ
    âŠ
      if (hook) {âŠ
        if (options.functional) {âŠ
          // register for functional component in vue fileâŠ
          var originalRender = options.render;âŠ
    âŠ
          options.render = function renderWithStyleInjection(h, context) {âŠ
            hook.call(context);âŠ
            return originalRender(h, context);âŠ
          };âŠ
        } else {âŠ
          // inject component registration as beforeCreate hookâŠ
          var existing = options.beforeCreate;âŠ
          options.beforeCreate = existing ? [].concat(existing, hook) : [hook];âŠ
        }âŠ
      }âŠ
    âŠ
      return script;âŠ
    }âŠ
    âŠ
    var normalizeComponent_1 = normalizeComponent;âŠ
    âŠ
    /* script */âŠ
    const __vue_script__ = script;âŠ
    // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258âŠ
    script.__file = "Greeting.vue";âŠ
    âŠ
    /* template */âŠ
    var __vue_render__ = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.name),expression:"name"}],domProps:{"value":(_vm.name)},on:{"input":function($event){if($event.target.composing){ return; }_vm.name=$event.target.value;}}}),_vm._v(" "),_c('div',[_vm._v("Hello "+_vm._s(_vm.name)+"!")])])};âŠ
    var __vue_staticRenderFns__ = [];âŠ
    âŠ
      /* style */âŠ
      const __vue_inject_styles__ = undefined;âŠ
      /* scoped */âŠ
      const __vue_scope_id__ = undefined;âŠ
      /* module identifier */âŠ
      const __vue_module_identifier__ = undefined;âŠ
      /* functional template */âŠ
      const __vue_is_functional_template__ = false;âŠ
      /* style inject */âŠ
      âŠ
      /* style inject SSR */âŠ
      âŠ
    âŠ
      âŠ
      var Greeting = normalizeComponent_1(âŠ
        { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },âŠ
        __vue_inject_styles__,âŠ
        __vue_script__,âŠ
        __vue_scope_id__,âŠ
        __vue_is_functional_template__,âŠ
        __vue_module_identifier__,âŠ
        undefined,âŠ
        undefinedâŠ
      );âŠ
    âŠ
    exports.Greeting = Greeting;âŠ
    `

## dist file is transpiled when --babel passed

> Snapshot 1

    'ğŸ’¿ Writing CommonJS dist file: tmp/two.js'

> Snapshot 2

    `'use strict';âŠ
    âŠ
    class SomeClass {}âŠ
    âŠ
    var exportDefaultNewExpression = new SomeClass();âŠ
    âŠ
    module.exports = exportDefaultNewExpression;âŠ
    `
